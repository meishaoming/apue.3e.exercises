## 7.1

"hello, world\n" 是 13 个字符，`printf` 打印这个字符串后的返回值是 13 ，这个值存在返回寄存器中，最后也被认为 main 的返回值。

但是我在 macos 上试验了，并不能返回 13，而是 0（即使用使用 `gcc -std=c89` 来编译）。

## 7.2

`main` 函数 return 或 主动调用 exit 时，atexit 注册的函数都会被回调到，也就会正常打印 printf 的值。

## 7.3

把 argc 和 argv 的值设置到环境变量中。

## 7.4

## 7.5

```c
typedef void (*Exitfunc)(void);

int atexit(Exitfunc func)
```

## 7.6

是的，calloc 分配的内存都为 0，不论已分配的内存用于何种数据类型。

## 7.7

正在执行的程序才有堆和栈。而对于一个存储在磁盘中的可执行文件来说，没有堆和栈的概念。

## 7.8

因为还有其它段存储在文件中。比如符号表、调试信息、链接表等。

## 7.9

使用共享库后，那些使用到的库函数没有链接到最终的「可执行文件」中来。而是在执行时加载。

简单的程序本身的代码量很少，大部分工作由库函数中处理。少了这些库函数，文件尺寸就小了很多。

## 7.10

自动变量在该函数的栈帧中，函数返回后，栈帧就回退了。这部分空间会作为下一次调用函数的栈帧。

所以，不能返回指向自动变量的指针。这个程序也是错误的。





